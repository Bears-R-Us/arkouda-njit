"""Sample Arachne Script for Property Graphs

This script provides an example on how a graph is built in Arachne from two Arkouda arrays and then
analyzed using Arachne functions. The graphs are randomly generated by using the ak.randint function
with the range of the vertex names being picked from 0..<n and the number of edges m. No special
distribution is used to generated the graph e.g. RMAT. We also generate random strings to behave
as relationships and labels for the property graphs.

The values of n and m are accepted from command line input. It requires Arkouda and Arachne to both
be pip installed in the environment. 

Assumes Arkouda server is running. It will shutdown the Arkouda server upon completion.

Sample usage: python3 arachne_simple_tests.py n51 5555 5000 20000

"""
import argparse
import time
import arkouda as ak
import arachne as ar
import networkx as nx


def create_parser():
    """Creates the command line parser for this script"""
    script_parser = argparse.ArgumentParser(
        description="Simple script showcasing all the functionality of Arachne on a random property\
                     graph of size specified by the user."
    )
    script_parser.add_argument("hostname", help="Hostname of arkouda server")
    script_parser.add_argument("port", type=int, default=5555, help="Port of arkouda server")
    script_parser.add_argument("n", type=int, default=1000, help="Number of vertices for graph")
    script_parser.add_argument("m", type=int, default=2000, help="Number of edges for graph")
    script_parser.add_argument("x", type=int, default=5, help="Number of labels for graph")
    script_parser.add_argument("y", type=int, default=10, help="Number of relationships for graph")

    return script_parser
if __name__ == "__main__":
    # Command line parser and extraction.
    parser = create_parser()
    args = parser.parse_args()

    # Connect to the Arkouda server.
    ak.verbose = False
    ak.connect(args.hostname, args.port)
    """
    ### Build graph from randomly generated source and destination arrays.
    # 1. Use Arkouda's randint to generate the random edge arrays.
    src = ak.randint(0, args.n, args.m, seed=2048)
    dst = ak.randint(0, args.n, args.m, seed=1024)

    # 2. Build property graph.
    start = time.time()
    prop_graph = ar.PropGraph()
    ################################################################################
    
    src= ak.array([2, 3, 5, 6, 7, 9])
    dst= ak.array([5, 6, 1, 6, 9, 2, 7, 10, 3, 8])
    ################################################################################

    prop_graph.add_edges_from(src, dst)
    end = time.time()
    print(f"Building property graph with {len(prop_graph)} vertices and {prop_graph.size()} "
          f"edges took {end-start} seconds.")

    ### Populate property graph with vertex labels.
    # 1. Generate labels.
    LBL = "label"
    #labels = [LBL + str(x) for x in range(args.x)]
    ###############################################################################
    lables=["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]
    ###############################################################################
    labels = ak.array(labels)

    # 2. Generate random array of vertices with original vertex values.
    vertices = prop_graph.nodes()
    vertices_with_labels = ak.randint(0, len(prop_graph), len(prop_graph), seed=512)
    
    vertices_with_labels = vertices[vertices_with_labels]

    # 3. Generate random array of labels of the same size as the random array of vertices above.
    random_labels = ak.randint(0, len(labels), len(vertices_with_labels), seed=256)
    random_labels = labels[random_labels]

    # 4. Pack the values into a dataframe and populate them into the graph.
    label_df = ak.DataFrame({"vertex_ids" : vertices_with_labels, "vertex_labels" : random_labels})
    start = time.time()
    
    #prop_graph.add_node_labels(label_df, "DipSLLaddNodeLabels")
    prop_graph.add_node_labels(label_df)
    
    end = time.time()
    print(f"Populating property graph with {len(random_labels)} labels took {end-start} seconds.")

    ### Populate property graph with edge relationships.
    # 1. Generate labels.
    #REL = "relationship"
    #relationships = [REL + str(y) for y in range(args.y)]
    ##########################################################################
    relationships = ["Y", "Y", "B", "R", "W", "G", "R", "W", "G", "B"]
    ############################################################################
    relationships = ak.array(relationships)

    # 2. Generate random array of edges with original vertex values.
    edges_with_relationships = ak.randint(0, len(src), len(src), seed=128)
    src_vertices_with_relationships = src[edges_with_relationships]
    dst_vertices_with_relationships = dst[edges_with_relationships]

    # 3. Generate random array of relationships of the same size as the random array of edges above.
    random_relationships = ak.randint(0, len(relationships), len(edges_with_relationships), seed=64)
    random_relationships = relationships[random_relationships]

    # 4. Pack the values into a dataframe and populate them into the graph.
    relationships_df = ak.DataFrame({"src" : src_vertices_with_relationships, "dst" : dst_vertices_with_relationships, "edge_relationships" : random_relationships})
    start = time.time()
    prop_graph.add_edge_relationships(relationships_df)
    end = time.time()
    print(f"Populating property graph with {len(random_relationships)} relationships took {end-start} seconds.")
    
    prop_graph = ar.PropGraph()
    
    #src= ak.array([101, 102, 104, 104, 104, 105, 105, 105, 106, 106, 108])
    #dst= ak.array([104, 105, 100, 105, 108, 101, 106, 109, 102, 110, 107])
    
    src= ak.array([100,  101,   108,  102,  109,  103,  110,  104,  111, 105,  112,  112,  107,  108,  109,  110,  111,  107,  113,  114, 108,  114, 115,  109,  115,  116,  110,  116,  117,  111,  117, 118,  112, 118,  119,  114,  115, 116,        200,  201,   208,  202,  209,  203,  210,  204,  211, 205,  212,  212,  207,  208,  209,  210,  211,  207,  213,  214, 208,  214, 215,  209,  215,  216,  210,  216,  217,  211,  217, 218,  212, 218,  219,  214,  215, 216,      300,  301,   308,  302,  309,  303,  310,  304,  311, 305,  312,  312,  307,  308,  309,  310,  311,  307,  313,  314, 308,  314, 315,  309,  315,  316,  310,  316,  317,  311,  317, 318,  312, 318,  319,  314,  315, 316,        400,  401,   408,  402,  409,  403,  410,  404,  411, 405,  412,  412,  407,  408,  409,  410,  411,  407,  413,  414, 408,  414, 415,  409,  415,  416,  410,  416,  417,  411,  417, 418,  412, 418,  419,  414,  415, 416])
    dst= ak.array([107,  107,   101,  108,  102,  109,  103,  110,  104, 111,  105,  106,  108,  109,  110,  111,  112,  113,  114,  107, 114,  115, 108,  115,  116,  109,  116,  117,  110,  117,  118, 111,  118, 119,  112,  120,  121, 122,        207,  207,   201,  208,  202,  209,  203,  210,  204, 211,  205,  206,  208,  209,  210,  211,  212,  213,  214,  207, 214,  215, 208,  215,  216,  209,  216,  217,  210,  217,  218, 211,  218, 219,  212,  220,  221, 222,      307,  307,   301,  308,  302,  309,  303,  310,  304, 311,  305,  306,  308,  309,  310,  311,  312,  313,  314,  307, 314,  315, 308,  315,  316,  309,  316,  317,  310,  317,  318, 311,  318, 319,  312,  320,  321, 322,        407,  407,   401,  408,  402,  409,  403,  410,  404, 411,  405,  406,  408,  409,  410,  411,  412,  413,  414,  407, 414,  415, 408,  415,  416,  409,  416,  417,  410,  417,  418, 411,  418, 419,  412,  420,  421, 422])    
    
    
    prop_graph.add_edges_from(src,dst)
    node_labels = ak.DataFrame({"vertex_ids"    : ak.array([100,101,102,103,104,105,106,107,108,109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,    200,201,202,203,204,205,206,207,208,209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,       300,301,302,303,304,305,306,307,308,309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322,    400,401,402,403,404,405,406,407,408,409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422]), 
                                "vertex_labels" : ak.array(["label1", "label1", "label1", "label1","label1", "label1", "label1", "label1", "label1", "label1","label1", "label1", "label1", "label1","label1", "label1", "label1", "label1", "label1", "label1", "label1", "label1", "label1",      "label1", "label1", "label1", "label1","label1", "label1", "label1", "label1", "label1", "label1","label1", "label1", "label1", "label1","label1", "label1", "label1", "label1", "label1", "label1", "label1", "label1", "label1",       "label1", "label1", "label1", "label1","label1", "label1", "label1", "label1", "label1", "label1","label1", "label1", "label1", "label1","label1", "label1", "label1", "label1", "label1", "label1", "label1", "label1", "label1",      "label1", "label1", "label1", "label1","label1", "label1", "label1", "label1", "label1", "label1","label1", "label1", "label1", "label1","label1", "label1", "label1", "label1", "label1", "label1", "label1", "label1", "label1"])})
    
    edge_relationships = ak.DataFrame({"src" : ak.array([100,  101,   108,  102,  109,  103,  110,  104,  111, 105,  112,  112,  107,  108,  109,  110,  111,  107,  113,  114, 108,  114, 115,  109,  115,  116,  110,  116,  117,  111,  117, 118,  112, 118,  119,  114,  115, 116,        200,  201,   208,  202,  209,  203,  210,  204,  211, 205,  212,  212,  207,  208,  209,  210,  211,  207,  213,  214, 208,  214, 215,  209,  215,  216,  210,  216,  217,  211,  217, 218,  212, 218,  219,  214,  215, 216,      300,  301,   308,  302,  309,  303,  310,  304,  311, 305,  312,  312,  307,  308,  309,  310,  311,  307,  313,  314, 308,  314, 315,  309,  315,  316,  310,  316,  317,  311,  317, 318,  312, 318,  319,  314,  315, 316,        400,  401,   408,  402,  409,  403,  410,  404,  411, 405,  412,  412,  407,  408,  409,  410,  411,  407,  413,  414, 408,  414, 415,  409,  415,  416,  410,  416,  417,  411,  417, 418,  412, 418,  419,  414,  415, 416]), 
                                       "dst" : ak.array([107,  107,   101,  108,  102,  109,  103,  110,  104, 111,  105,  106,  108,  109,  110,  111,  112,  113,  114,  107, 114,  115, 108,  115,  116,  109,  116,  117,  110,  117,  118, 111,  118, 119,  112,  120,  121, 122,        207,  207,   201,  208,  202,  209,  203,  210,  204, 211,  205,  206,  208,  209,  210,  211,  212,  213,  214,  207, 214,  215, 208,  215,  216,  209,  216,  217,  210,  217,  218, 211,  218, 219,  212,  220,  221, 222,      307,  307,   301,  308,  302,  309,  303,  310,  304, 311,  305,  306,  308,  309,  310,  311,  312,  313,  314,  307, 314,  315, 308,  315,  316,  309,  316,  317,  310,  317,  318, 311,  318, 319,  312,  320,  321, 322,        407,  407,   401,  408,  402,  409,  403,  410,  404, 411,  405,  406,  408,  409,  410,  411,  412,  413,  414,  407, 414,  415, 408,  415,  416,  409,  416,  417,  410,  417,  418, 411,  418, 419,  412,  420,  421, 422]), 
                        "edge_relationships" : ak.array(["Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1","Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1","Y1", "Y1","Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1","Y1", "Y1","Y1", "Y1", "Y1", "Y1", "Y1",       "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1","Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1","Y1", "Y1","Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1","Y1", "Y1","Y1", "Y1", "Y1", "Y1", "Y1",     "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1","Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1","Y1", "Y1","Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1","Y1", "Y1","Y1", "Y1", "Y1", "Y1", "Y1",       "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1","Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1","Y1", "Y1","Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1","Y1", "Y1","Y1", "Y1", "Y1", "Y1", "Y1"])})
    
    prop_graph.add_node_labels(node_labels)
    prop_graph.add_edge_relationships(edge_relationships)
    
    src = ak.array([3, 1, 3, 4, 2, 4, 5, 5, 4, 3, 7, 1, 2, 8, 7, 9, 8])
    dst = ak.array([0, 3, 4, 1, 4, 5, 2, 9, 8, 7, 6, 0, 1, 7, 4, 8, 5])
    prop_graph = ar.PropGraph()
    prop_graph.add_edges_from(ak.array(src),ak.array(dst))

    
    node_labels = ak.DataFrame({"vertex_ids"    : ak.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), 
                                "vertex_labels" : ak.array(["label1","label1","label1","label1","label1",
                                                            "label1","label1","label1","label1","label1","label1"])})
    
    edge_relationships = ak.DataFrame({"src" : ak.array(src), 
                                       "dst" : ak.array(dst), 
                        "edge_relationships" : ak.array(["Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1",
                                                                        "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1","Y1", "Y1"])})

    prop_graph.add_node_labels(node_labels)
    prop_graph.add_edge_relationships(edge_relationships)


#    prop_graph.add_edges_from(ak.array(src_array) ,ak.array(dst_array) )

    ### Test subgraph isomorphism.
    
    subgraph = ar.PropGraph()
    
    src1= ak.array([0, 1, 2, 1])
    dst1= ak.array([1, 2, 0, 3])
    
    subgraph.add_edges_from(src1,dst1)
    node_labels = ak.DataFrame({"vertex_ids" : ak.array([0, 1 ,2, 3]), 
                                "vertex_labels" : ak.array(["label1", "label1", "label1", "label1"])})
    edge_relationships = ak.DataFrame({"src" : ak.array([0, 1, 2, 1]), 
                                       "dst" : ak.array([1, 2, 0, 3]), 
                    "edge_relationships" : ak.array(["Y1", "Y1", "Y1", "Y1"])})
    subgraph.add_node_labels(node_labels)
    subgraph.add_edge_relationships(edge_relationships)
#    
#    node_labels = ak.DataFrame({"vertex_ids"    : ak.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]), 
#                                "vertex_labels" : ak.array(["label1","label1","label1","label1",
#                                                            "label1","label1","label1","label1","label1","label1"])})
#    
#    edge_relationships = ak.DataFrame({"src" : ak.array([0, 0, 0, 1, 2, 2, 3, 6, 7, 7, 7, 7]), 
#                                       "dst" : ak.array([1, 3, 5, 3, 1, 3, 4, 0, 0, 6, 8, 9]), 
#                        "edge_relationships" : ak.array(["Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1", "Y1",
#                                                                                  "Y1","Y1", "Y1", "Y1"])})
    start_time1 = time.time()
 
    mappings_df = ar.subgraph_isomorphism_VF2(prop_graph, subgraph, "VF2")
    # Access the DataFrame data
    print("VF2 subgraph_isomorphism run and this is the found ISOs")
    print(mappings_df)
    print(len(mappings_df))
    elapsed_time1 = time.time() - start_time1
    print(f"Execution time: {elapsed_time1} seconds")
    
    """
    import networkx as nx
    import time

    # Get the NetworkX version
    print("NetworkX version:", nx.__version__)
    # Creating directed graphs
    G = nx.DiGraph()
    H = nx.DiGraph()

    # Clearing graphs (optional in this context)
    G.clear()
    H.clear()

    # Adding nodes and edges to directed graphs
    G.add_nodes_from(range(0, 10))
    G.add_edges_from([(3, 0), (1, 3), (4, 1), (2, 4), (5, 2), (3, 4), (4, 5), 
                      (3, 7), (7, 6), (4, 8), (5, 9),(1, 0),(2,1),(8, 7), (7,4), (8, 5), (9,8)])

    H.add_nodes_from(range(0, 4))
    H.add_edges_from([(0, 1), (1, 2), (2, 0), (1, 3)])
    #H.add_edges_from([(3, 1), (1, 2), (2, 3), (1, 0)])

    node_label = 'NodeLabel'
    edge_label = 'EdgeLabel'
    nx.set_node_attributes(G, node_label, 'label1')
    nx.set_edge_attributes(G, edge_label, 'Y1')

    nx.set_node_attributes(H, node_label, 'label1')
    nx.set_edge_attributes(H, edge_label, 'Y1')
    
   
    # Measure execution time
    start_time = time.time()

    # Find subgraph isomorphisms of H in G
    GM = nx.algorithms.isomorphism.DiGraphMatcher(G, H)
    subgraph_isomorphisms = list(GM.subgraph_monomorphisms_iter())

    print("NetworkX subgraph_isomorphism found ISOs:", len(subgraph_isomorphisms))
    print("Subgraph isomorphisms found:")
    for iso in subgraph_isomorphisms:
        print(iso)
        
    elapsed_time = time.time() - start_time
        
    print(f"Execution time: {elapsed_time} seconds")
    
   #////////////////////////////////////////////////////////// 
    
    # Extracting src and dst arrays from G
    edgesG = G.edges()
    srcG = [edge[0] for edge in edgesG]
    dstG = [edge[1] for edge in edgesG]


    
    # Extracting all_nodes array
    vertex_idsG = list(G.nodes())
    vertex_labelsG = ['label1'] * len(vertex_idsG)
    edge_relationshipsG = ['Y1'] * len(srcG)
    

    prop_graph = ar.PropGraph()
    
    prop_graph.add_edges_from(ak.array(srcG),ak.array(dstG))
    
    node_labelsG = ak.DataFrame({"vertex_ids" : ak.array(vertex_idsG), 
                                "vertex_labels" : ak.array(vertex_labelsG)})
    edge_relationshipsG = ak.DataFrame({"src" : ak.array(srcG), 
                                       "dst" : ak.array(dstG), 
                    "edge_relationships" : ak.array(edge_relationshipsG)})
    prop_graph.add_node_labels(node_labelsG)
    prop_graph.add_edge_relationships(edge_relationshipsG)

    
     # Extracting src and dst arrays from H
    edgesH = H.edges()
    srcH = [edge[0] for edge in edgesH]
    dstH = [edge[1] for edge in edgesH]


    
    # Extracting all_nodes array H
    vertex_idsH = list(H.nodes())
    vertex_labelsH = ['label1'] * len(vertex_idsH)
    edge_relationshipsH = ['Y1'] * len(srcH)
    
 

    subgraph = ar.PropGraph()
    
    subgraph.add_edges_from(ak.array(srcH),ak.array(dstH))
    
    node_labelsH = ak.DataFrame({"vertex_ids" : ak.array(vertex_idsH), 
                                "vertex_labels" : ak.array(vertex_labelsH)})
    edge_relationshipsH = ak.DataFrame({"src" : ak.array(srcH), 
                                       "dst" : ak.array(dstH), 
                    "edge_relationships" : ak.array(edge_relationshipsH)})
    subgraph.add_node_labels(node_labelsH)
    subgraph.add_edge_relationships(edge_relationshipsH)
    
    start_time1 = time.time()
 
    mappings_df = ar.subgraph_isomorphism_VF2(prop_graph, subgraph, "VF2")
    # Access the DataFrame data
    print("VF2 subgraph_isomorphism run and this is the found ISOs:")
    #print(mappings_df)
    print(len(mappings_df)/4)
    for i in range(0, len(mappings_df), 4):
        print(mappings_df[i:i+4])
    elapsed_time1 = time.time() - start_time1
    print(f"Execution time: {elapsed_time1} seconds")
    
    print("srcG = ",srcG)
    print("dstG = ",dstG)
    print("number of edges: ", len(edgesG))
    print("number of nodes: ", len(vertex_idsG))
    print("subgraph #edges: ", len(edgesH))
    print("subgraph #nodes: ", len(vertex_idsH))
    
    start_time = time.time()

    mappings_df = ar.subgraph_isomorphism(prop_graph, subgraph, "ullmann")
    #print(type(mappings_df)) 
    # Access the DataFrame data
    print("Ullmann subgraph_isomorphism run and this is the found ISOs")
    print(mappings_df)
    print(len(mappings_df))
    
    end_time = time.time()
    elapsed_time = end_time - start_time
    print("Elapsed time:", elapsed_time, "seconds")
    print("*********************************************************************************")
    ak.shutdown()

