"""Breadth-First Search Benchmark

This script provides a benchmark on a graph built in Arachne from two Arkouda arrays. The graphs are 
randomly generated by using the ak.randint function with the range of the vertex names being picked 
from [0,n-1] and the number of edges m. No special distribution is used to generated the graph. 

The values of n and m are accepted from command line input. As well as the number of trials for
executing breadth-first search.

Assumes Arkouda server is running. It will shutdown the Arkouda server upon completion.

Sample usage: python3 breadth_first_search.py n1 5555 5000 20000 5

"""
import argparse
import time
import statistics as st
import arkouda as ak
import arachne as ar

def create_parser():
    """Creates the command line parser for this script"""
    script_parser = argparse.ArgumentParser(
        description="Simple script showcasing all the functionality of Arachne on a random graph of\
                     size specified by the user."
    )
    script_parser.add_argument("hostname", help="Hostname of arkouda server")
    script_parser.add_argument("port", type=int, default=5555, help="Port of arkouda server")
    script_parser.add_argument("n", type=int, default=1000, help="Number of vertices for graph")
    script_parser.add_argument("m", type=int, default=2000, help="Number of edges for graph")
    script_parser.add_argument("trials", type=int, default=5, help="Number of times to run BFS")

    return script_parser

if __name__ == "__main__":
    # Command line parser and extraction.
    parser = create_parser()
    args = parser.parse_args()

    # Connect to the Arkouda server.
    ak.verbose = False
    ak.connect(args.hostname, args.port)

    ### Build graph from randomly generated source and destination arrays.
    # 1. Use Arkouda's randint to generate the random edge arrays.
    src = ak.randint(0, args.n, args.m)
    dst = ak.randint(0, args.n, args.m)

    # 2. Build undirected graph.
    print("### Arachne Graph Building")
    start = time.time()
    graph = ar.Graph()
    graph.add_edges_from(src, dst)
    end = time.time()
    print(f"Building undirected graph with {len(graph)} vertices and {graph.size()} edges "
          f"took {round(end-start,2)} seconds")

    # 3. Build directed graph.
    start = time.time()
    di_graph = ar.DiGraph()
    di_graph.add_edges_from(src, dst)
    end = time.time()
    print(f"Building directed graph with {len(di_graph)} vertices and {di_graph.size()} "
          f"edges took {round(end-start,2)} seconds")
    print()

    print("Arachne Breadth-First Search")
    ### Run Arachne breadth-first search on the input graphs.
    # 1. BFS on undirected graph.
    undirected_bfs_trials = []
    highest_degree = ak.argmax(graph.degree())
    for _ in range(args.trials):
        start = time.time()
        graph_bfs_layers = ar.bfs_layers(graph, int(graph.nodes()[highest_degree]))
        end = time.time()
        undirected_bfs_trials.append(end-start)
    avg_runtime_undirected = round(st.mean(undirected_bfs_trials),2)
    print(f"Running breadth-first search on undirected graph took on average "
          f"{avg_runtime_undirected} seconds.")

    # 2. BFS on directed graph.
    directed_bfs_trials = []
    highest_out_degree = ak.argmax(di_graph.out_degree())
    for _ in range(args.trials):
        start = time.time()
        di_graph_bfs_layers = ar.bfs_layers(di_graph, int(di_graph.nodes()[highest_out_degree]))
        end = time.time()
        directed_bfs_trials.append(end-start)
    avg_runtime_directed = round(st.mean(directed_bfs_trials),2)
    print(f"Running breadth-first search on directed graph took on average {avg_runtime_directed} "
          f"seconds.")
    print()

    ak.shutdown()
